<!doctype html>
<html lang="en">

<head>
    <meta charset="utf-8">

    <title>Statistical Computing</title>

    <meta name="author" content="Xi (Rossi) LUO">

    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="reveal.js.4.1.3/dist/reset.css">
    <link rel="stylesheet" href="reveal.js.4.1.3/dist/reveal.css">
    <!-- <link rel="stylesheet" href="reveal.js.4.1.3/dist/theme/white.css" id="theme"> -->



    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="reveal.js.4.1.3/plugin/highlight/github-dark-dimmed.min.css">
    <!--
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css">
-->
    <link rel="stylesheet" href="./css/rossisimple.css" id="theme">
    <!--    <link rel="stylesheet" href="./css/brightRoom.css" id="theme">-->
</head>

<body>

    <div class="reveal">

        <!-- Any section element inside of this container is displayed as a slide -->
        <div class="slides">

            <!--      place holder for credits: empty for now -->
            <credit></credit>
            <section>
                <h1><strong>
                        <highlight>Statistical</highlight>
                        <emph>Computing</emph>
                    </strong></h1>
                <br>
                <h2>Lec06 Prog/Function</h2>
                <br>

                <h3>Xi (Rossi) <strong>LUO</strong></h3>
                <br>
                <p><small>Department of Biostatistics and Data Science<br>
                        School of Public Health<br>The University of Texas Health Science Center at Houston</small></p>
            </section>

            <section>
                <h1>Control Statements</h1>
            </section>

            <section>
                <h2>Loop Over Non-vector</h2>
                <pre><code data-trim data-noescape class="language-r">
                    u <- matrix(runif(10), ncol=2)
                    v <- matrix(runif(10), ncol=2)
                    for (m in c("u", "v")) {
                        z <- get(m)
                    }
                </code></pre>
                <p>
                    <empphcode>get</empphcode> values from var names and optionally from a specified environment
                </p>
            </section>

            <section>
                <h2>Return Complex Objects</h2>
                <ul>
                    <li>R can return functions from functions (more later)</li>
                    <li>Typically multiple objects grouped together by returning a list</li>
                </ul>
            </section>


            <section>
                <h1>Function</h1>
            </section>

            <section>
                <h2>Functions as Objects</h2>
                <ul>
                    <li>Can assign function to other names like objects</li>
                    <li>Loop through <emphcode>list</emphcode> of functions</li>
                    <li>Return functions</li>
                    <li>Modify functions by <emphcode>formals, body</emphcode>
                    </li>
                    <li>Primitive function calls C/Fortran/..., NULL formal and body</li>
                </ul>
            </section>

            <section>
                <h2>Function Composition</h2>
                <ul>
                    <li>Function composition improves clarity and performance sometimes</li>
                    <li>Linux-like pipe operator by <emphcode>magrittr</emphcode>
                    </li>
                </ul>
            </section>

            <section>
                <pre><code data-trim data-noescape class="language-r">
                    library(magrittr)
                    x %>%
                      deviation() %>%
                      square() %>%
                      mean() %>%
                      sqrt()
                </code></pre>
                <p>VS</p>
                <pre><code data-trim data-noescape class="language-r">
                    sqrt(mean(square(deviation(x))))
                    out <- deviation(x)
                    out <- square(out)
                    out <- mean(out)
                    out <- sqrt(out)
                    out
                </code></pre>
            </section>

            <section>
                <h2>Pipe</h2>
                <ul>
                    <li>Focus on operations rather than object modification</li>
                    <li>x %>% f(y) is equivalent to f(x, y)</li>
                    <li>Only possible for single object sequence</li>
                    <li>Nesting, f(g(x)), suited for short sequences but hard to read/write for long ones</li>
                    <li>Intermediate objects, y &lt;- f(x) also hard to read</li>
                </ul>
            </section>

            <section>
                <h2>Function Form</h2>
                <ul>
                    <li>Prefix: <emphcode>f(x, y, z)</emphcode>
                    </li>
                    <li>Infix: <emphcode>x + y</emphcode>, <emphcode>+</emphcode> is a function</li>
                    <li>Replacement: <emphcode>names(df) <- c("a")</emphcode>
                    </li>
                    <li>Special: <emphcode>[[</emphcode>
                    </li>
                </ul>
            </section>

            <section>
                <h2>Example</h2>
                <pre><code data-trim data-noescape class="language-r">
                    x + y
                    `+`(x, y)
                    
                    names(df) <- c("x", "y", "z")
                    `names<-`(df, c("x", "y", "z"))
                    
                    for(i in 1:10) print(i)
                    `for`(i, 1:10, print(i))             
                </code></pre>
                <pre><code data-trim data-noescape class="language-r">
                    > `names<-`
                    function (x, value)  .Primitive("names<-")
                    > `+`
                    function (e1, e2)  .Primitive("+")
                </code></pre>
            </section>


            <section>
                <h2>Replacement Function</h2>
                <pre><code data-trim data-noescape class="language-r">
                    names(x) &lt;- c("a", "b", "c")
                </code></pre>
                <p>is actually calling a function <emphcode>`names&lt;-`</emphcode>
                </p>
                <pre><code data-trim data-noescape class="language-r">
                    x &lt;- `names(x)&lt;-`(x, value = c("a", "b", "c") )
                </code></pre>
            </section>

            <section>
                <h2>Replacement Function</h2>
                <pre><code data-trim data-noescape class="language-r">
                    x[2:3] &lt;- 99:100
                </code></pre>
                <p>is actually calling a function <emphcode>`[&lt;-`</emphcode>
                </p>
                <pre><code data-trim data-noescape class="language-r">
                    x &lt;- `[&lt;-`(x, 2:3, value = 99:100 )
                </code></pre>
            </section>

            <section>
                <h2>Example</h2>
                <pre><code data-trim data-noescape class="language-r">
                    # function to read
                    "[.bookvec" <- function(bv,subs) {
                       return(bv$vec[subs])
                    }                    
                    # function to write
                    "[<-.bookvec" <- function(bv,subs,value) {
                       bv$wrts[subs] <- bv$wrts[subs] + 1  # note the recycling
                       bv$vec[subs] <- value
                       return(bv)
                    }                    
                </code></pre>
            </section>

            <section>
                <h1>Argument</h1>
            </section>

            <section>
                <h2>Argument</h2>
                <ul>
                    <li>Matched by exact name, then unique prefixes, and finally by position</li>
                    <li>Try to use positional matching for the first one or two arguments</li>
                    <li>Avoid partial matching by prefixes</li>
                    <li>Set (default) argument by <emphcode>=</emphcode> not <emphcode>&lt;-</emphcode>
                    </li>
                </ul>
            </section>

            <section>
                <h2>...</h2>
                <p>Pass arguments (not matched) to another function inside, usually used to pass additional optional
                    arguments used by another function</p>
                <pre><code data-trim data-noescape class="language-r">
                    i01 <- function(y, z) {
                        list(y = y, z = z)
                    }                      
                    i02 <- function(x, ...) {
                    i01(...)
                    }                      
                    str(i02(x = 1, y = 2, z = 3))
                    #> List of 2
                    #>  $ y: num 2
                    #>  $ z: num 3        
                </code></pre>
            </section>

            <section>
                <h2>Function and Environment</h2>
            </section>

            <section>
                <h2>Closure</h2>
                <ul>
                    <li>Three components: arguments, body, and environment, except <emphcode>primitive</emphcode>
                        functions written in other languages</li>
                    <li>Env contains objects when function created</li>
                    <li>Command prompt is the top level, aka <emphcode>.GlobalEnv</emphcode>
                    </li>
                    <li>
                        <emphcode>ls</emphcode> or <emphcode>ls.str</emphcode> lists the objects in env
                    </li>
                    <li>
                        <emph>local</emph>: lower level/within; <emph>global</emph>: higher level/outside
                    </li>
                </ul>
            </section>

            <section>
                <h2>Example 7.6.1</h2>
                <pre><code data-trim data-noescape class="language-r">
                    w <- 12
                    f <- function(y) {
                        d <- 8
                        h <- function() {
                           return(d*(w+y))
                        }
                        print(environment(h))
                        return(h())
                     }                    
                </code></pre>
                <ul>
                    <li>
                        <emphcode>d, h, y</emphcode> local to <emphcode>f</emphcode>, not visible outside
                    </li>
                    <li>
                        <emphcode>d</emphcode> is global to <emphcode>h</emphcode>
                    </li>
                    <li>
                        <emphcode>w</emphcode> is global to <emphcode>h, f</emphcode>
                    </li>
                </ul>
            </section>


            <section>
                <h2>Environment</h2>
                <ul>
                    <li>
                        <emphcode>h</emphcode> env contains <emphcode>d, y</emphcode> plus
                        <emphcode>f</emphcode> env
                    </li>
                    <li>Nested functions have larger env</li>
                    <li>R locates variables by starting from local variables (lower level, where functions were defined)
                        to global (higher level),
                        until they are found</li>
                    <li>Local variable assignment does not impact global variables, exception superassignment</li>
                </ul>
            </section>

            <section>
                <h2>Example 7.6.1</h2>
                <pre><code data-trim data-noescape class="language-r">
                    w <- 12
                    f <- function(y) {
                        d <- 8
                        return(h(d, y))
                    }
                    h <- function(dee, yyy) {
                        print(ls())
                        print(ls(envir=parent.frame(n=1)))
                        return(dee*(w+yyy))
                    }
                </code></pre>
                <ul>
                    <li>
                        <emphcode>ls</emphcode> list objects in current env (default)
                    </li>
                    <li>
                        <emphcode>parent.frame</emphcode> changes to higher level env
                    </li>
                </ul>
            </section>

            <section>
                <h2>Lexical Scoping</h2>
                <ul>
                    <li>Looks up where functions are <emph>defined</emph> not where they are <emph>called</emph>
                    </li>
                    <li>Four primary rules: name masking, functions like variables, fresh start, and dynamic lookup</li>
                </ul>
            </section>

            <section>
                <h2>Name Masking</h2>
                <ul>
                    <li>Names defined inside (lower level) mask names defined outside (higher level) </li>
                    <li>Use local variable values if can be found</li>
                    <li>R search one level up at a time, util found or reaching .GlobalEnv</li>
                </ul>
            </section>

            <section>
                <h2>Example</h2>
                <pre><code data-trim data-noescape class="language-r">
                    x <- 1
                    g04 <- function() {
                      y <- 2
                      i <- function() {
                        z <- 3
                        c(x, y, z)
                      }
                      i()
                    }
                    g04()
                </code></pre>
                <p class="fragment fade-up">Output: 1,2,3</p>
            </section>

            <section>
                <h2>Fresh Start</h2>
                <ul>
                    <li>New env created every time a function is called</li>
                    <li>New local variable values created in new env and destroyed when function returns</li>
                    <li>No way to remember what happened the last time it was run</li>
                    <li>Independent invocation and same behavior, good for parallel</li>
                    <li>Key for functional programming</li>
                    <li>Assignment within function is local (copy on modify)</li>
                    <li>Exceptions can occur if using functional closure</li>
                </ul>
            </section>

            <section>
                <h2>Example</h2>
                <pre><code data-trim data-noescape class="language-r">
                    g11 <- function() {
                        if (!exists("a")) {
                          a <- 1
                        } else {
                          a <- a + 1
                        }
                        a
                      }
                      g11()
                      g11()
                </code></pre>
                <p class="fragment fade-up">Output: 1‚èé 1</p>
            </section>

            <section>
                <h2>Exception</h2>
                <pre><code data-trim data-noescape class="language-r">
                    f <- function() {
                        i <- 0
                        function() {
                            i <<- i + 1
                            i
                        }
                    }                     
                </code></pre>
                <pre><code data-trim data-noescape class="language-r">
                    > g <- f()
                    > g()
                    [1] 1                
                    > g()
                    [1] 2
                </code></pre>
                <p>g remembers how many times it was called</p>
            </section>

            <section>
                <h2>Dynamic Lookup</h2>
                <ul>
                    <li>R looks up values when function is run, not when it is created</li>
                    <li>Name masking tells where to look but be aware of dependency on global variables</li>
                    <li>No errors for wrong variable names if not needed in running</li>
                    <li>R also infers the type (e.g. function vs object) when looking up</li>
                </ul>
            </section>

            <section>
                <h2>Example</h2>
                <pre><code data-trim data-noescape class="language-r">
                    g12 <- function() x + 1
                    x <- 15
                    g12()
                    #> [1] 16
                    
                    x <- 20
                    g12()
                    #> [1] 21
                </code></pre>
                <p>This may cause issues. One may set x as an input argument. Detect this issue using
                    codetools::findGlobals()</p>
                <pre><code data-trim data-noescape class="language-r">
                        codetools::findGlobals(g12)
                        #> [1] "+" "x"
                    </code></pre>
            </section>


            <section>
                <h2>Example 7.6.5</h2>
                <pre><code data-trim data-noescape class="language-r">
                    showframe <- function(upn) {
                        # determine the proper environment
                        if (upn < 0) {
                           env <- .GlobalEnv
                        } else {
                           env <- parent.frame(n=upn+1)
                        }
                        # get the list of variable names
                        vars <- ls(envir=env)
                        # for each variable name, print its value
                        for (vr in vars) {
                           print(env)
                           vrg <- get(vr,envir=env)
                           if (!is.function(vrg)) {
                              cat(vr,":\n",sep="")
                              print(vrg)
                           }
                        }
                     }                     
                </code></pre>
            </section>

            <section>
                <h2>Example 7.6.5</h2>
                <pre><code data-trim data-noescape class="language-r">
                    g <- function(aa) {
                        b <- 2
                        showframe(0)
                        showframe(1)
                        aab <- h(aa+b)
                        return(aab)
                     }
                     f <- function() {
                        a <- 1
                        return(g(a) + a)
                     }
                     h<- function(aaa) {
                        c <- 3
                        return(aaa + c)
                     }
                </code></pre>
            </section>

            <section>
                <h2>Example 7.6.5: Output</h2>
                <pre><code data-trim data-noescape class="language-r">
                    &gt; f()
                    &lt;environment: 0x7fc15d1c6598&gt;
                    aa:
                    [1] 1
                    &lt;environment: 0x7fc15d1c6598&gt;
                    b:
                    [1] 2
                    &lt;environment: 0x7fc15d1c66b0&gt;
                    a:
                    [1] 1
                    [1] 7
                </code></pre>
            </section>

            <section>
                <h2>No Pointers</h2>
                <ul>
                    <li>R does not change values of argument variables</li>
                    <li>Unlike C or Python, multiple arguments can be modified inside function</li>
                    <li>If returning multiple outputs, use list</li>
                    <li>Exception: use superassignment or global variables with caution</li>
                </ul>
            </section>

            <section>
                <h2>Superassignment</h2>
                <ul>
                    <li>
                        <emphcode>
                            &lt;&lt;-</emphcode> assigns values to current or upper-level variables
                    </li>
                    <li>Starts from current level, and one level up at a time, until a variable is found</li>
                    <li>If not found, variable is created in global env</li>
                    <li>Alternative: <emphcode>assign</emphcode> can specify the level explicitly</li>
                </ul>
            </section>

            <section>
                <h2>Example</h2>
                <pre><code data-trim data-noescape class="language-r">
                    x <- 0
                    f <- function() {
                      x <<- 1
                    }
                    f()
                    x
                    #> [1] 1     
                    # or
                    assign("x", 1, pos=.GlobalEnv)               
                </code></pre>
            </section>


            <section>
                <h2>Global Variables</h2>
                <ul>
                    <li>Using global variables is controversial</li>
                    <li>Functions may return different values due to changes in global variables</li>
                    <li>Hard to debug if many functions changes values around the same time</li>
                    <li>However, using global can be very convenient, especially for communicating between threads and
                        GPUs in parallel computing</li>
                    <li>It can greatly simplify codes</li>
                    <li>Generally not recommended</li>
                </ul>
            </section>


            <section>
                <h2>Prog Pattern: Closure</h2>
                <ul>
                    <li>A function contains local variables that can be assessed by another function defined within</li>
                    <li>Good practice to memorize states without pollute .GlobalEnv</li>
                    <li>Widely used in many other languages, including one called <emph>closure</emph>
                    </li>
                </ul>
            </section>

            <section>
                <h2>Old Example</h2>
                <pre><code data-trim data-noescape class="language-r">
                    f <- function() {
                        i <- 0
                        function() {
                            i <<- i + 1
                            i
                        }
                    }                     
                </code></pre>
                <pre><code data-trim data-noescape class="language-r">
                    > g <- f()
                    > g()
                    [1] 1                
                    > g()
                    [1] 2
                </code></pre>
                <p>g remembers how many times it was called</p>
            </section>


            <section>
                <h2>Example</h2>
                <pre><code data-trim data-noescape class="language-r">
                    > moment <- function(p) {
                    + function(x) mean(x^p)
                    + }
                    > m1 <- moment(1)
                    > m1(-10:10)
                    [1] 0
                    > m2 <- moment(2)
                    > m2(-10:10)
                    [1] 36.66667
                    > m3 <- moment(3)
                    > m3(-10:10)
                    [1] 0         
                </code></pre>
                <p>Simplifies writing multiple functions for 1st, 2ndm, 3rd and etc moments</p>
            </section>

            <section>
                <h1>Recursion</h1>
            </section>

            <section>
                <h2>Recursion</h2>
                <ul>
                    <li>Recursive function calls itself</li>
                    <li>Prog technique to solve complex problems that can be solved in iterative steps</li>
                    <li>Break large problems into smaller ones</li>
                    <li>Within f(), call f() itself on each of the smaller problems</li>
                    <li>Simple to program</li>
                </ul>
            </section>

            <section>
                <h2>Quick Sort Ex 7.9.1</h2>
                <pre><code data-trim data-noescape class="language-r">
                    qs <- function(x) {
                        if (length(x) <= 1) return(x)
                        pivot <- x[1]
                        therest <- x[-1]
                        sv1 <- therest[therest < pivot]
                        sv2 <- therest[therest >= pivot]
                        sv1 <- qs(sv1)
                        sv2 <- qs(sv2)
                        return(c(sv1,pivot,sv2))
                     }                    
                </code></pre>
            </section>

            <section>
                <h2>Issues</h2>
                <ul>
                    <li>Computation time may be long due to repeated calls</li>
                    <li>Memory issues with a large number of recursive calls</li>
                    <li>More on partially address these issues later</li>
                </ul>
            </section>


            <section>
                <h2>Function Tools</h2>
                <ul>
                    <li>
                        <emphcode>source</emphcode>
                    </li>
                    <li>
                        <emphcode>edit</emphcode>
                    </li>
                </ul>
            </section>

            <section>
                <h2>References</h2>
                <ul>
                    <li>AoRP: ch 7</li>
                    <li>AR: ch 6</li>
                </ul>
            </section>

        </div>

    </div>

    <script src="reveal.js.4.1.3/dist/reveal.js"></script>
    <script src="reveal.js.4.1.3/plugin/zoom/zoom.js"></script>
    <script src="reveal.js.4.1.3/plugin/notes/notes.js"></script>
    <script src="reveal.js.4.1.3/plugin/search/search.js"></script>
    <script src="reveal.js.4.1.3/plugin/markdown/markdown.js"></script>
    <script src="reveal.js.4.1.3/plugin/highlight/highlight.js"></script>
    <script src="reveal.js.4.1.3/plugin/math/math.js"></script>

    <script>
        // Also available as an ES module, see:
        // https://revealjs.com/initialization/
        Reveal.initialize({
            controls: false,
            progress: true,
            center: true,
            hash: true,
            transition: 'slide', // none/fade/slide/convex/concave/zoom

            width: 1024,
            height: 768,

            slideNumber: 'c/t',

            math: {
                // mathjax: 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js',
                config: 'TeX-AMS_HTML-full',
                TeX: {
                    Macros: {
                        R: '\\mathbb{R}',
                        set: ['\\left\\{#1 \\; ; \\; #2\\right\\}', 2]
                    }
                }
            },

            // Learn about plugins: https://revealjs.com/plugins/
            plugins: [RevealZoom, RevealNotes, RevealSearch, RevealMarkdown, RevealMath, RevealHighlight]
        });

    </script>

</body>

</html>